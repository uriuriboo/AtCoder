{
  "atcodertemplate": {
    "prefix": "tmplt",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "#define rep(i, n) for (int i = 0; i < (n); i++)",
      "#define rep2(i,k,n) for(int i = k;i < (n);i++)",
      "typedef long long ll;",
      "#define repl(i,n) for(ll i = 0;i < (n);i++)",
      "typedef pair <int,int> P;",
      "#define ALL(a) (a).begin(),(a).end()",
      "typedef vector<vector<int>> Graph;",
      "const ll MOD = 1e9 + 7;",
      "const int INF = 1e9;",
      "const ll lINF = 1e18;",
      "const int dx[4] = {1, 0, -1, 0};",
      "const int dy[4] = {0, 1, 0, -1};\n",
      "template <class T>",
      "inline bool chmin(T &a, T b) {",
      "\tif (a > b) {",
      "\t\ta = b;",
      "\t\treturn true;",
      "\t}",
      "\treturn false;",
      "}\n",
      "template <class T>",
      "inline bool chmax(T &a, T b) {",
      "\tif (a < b) {",
      "\t\ta = b;",
      "\t\treturn true;",
      "\t}",
      "\treturn false;",
      "}\n",
      "template <class T>",
      "T GCD(T a, T b) {",
      "\tif (b == 0)",
      "\t\treturn a;",
      "\telse",
      "\t\treturn GCD(b, a % b);",
      "}\n",
      "template <class T>",
      "inline T LCM(T a, T b) {",
      "\t return (a * b) / GCD(a, b);",
      "}\n",
      "template <class T>",
      "T nCr_naive(T n, int r) {",
      "\tT ret(1);",
      "\tfor (int i = 0; i < r; i++) {",
      "\t\tret *= n;",
      "\t\tret /= T(i + 1);",
      "\t\tn -= T(1);",
      "\t}",
      "\treturn ret;",
      "}\n",
      "int main(void){",
      "\tint n,m,ans = 0;",
      "\tcin >> n >> m;",
      "\tvector<int> a(n);",
      "\trep(i, n) cin >> a[i];\n",
      "\t$1\n",
      "\treturn 0;",
      "}"
    ],
    "description": "競プロのテンプレート"
  },
  "atcoder_n_templt": {
    "prefix": "ntemplt",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "#define rep(i, n) for (int i = 0; i < (n); i++)",
      "#define rep2(i,k,n) for(int i = k;i < (n);i++)",
      "typedef long long ll;",
      "#define repl(i,n) for(ll i = 0;i < (n);i++)",
      "typedef pair <int,int> P;",
      "#define ALL(a) (a).begin(),(a).end()",
      "typedef vector<vector<int>> Graph;",
      "const ll MOD = 1e9 + 7;",
      "const int INF = 1e9;",
      "const ll lINF = 1e18;",
      "const int dx[4] = {1, 0, -1, 0};",
      "const int dy[4] = {0, 1, 0, -1};\n",
      "int main(void){",
      "\tint n,ans = 0;",
      "\tcin >> n;",
      "\tvector<int> $1(n);",
      "\trep(i, n) cin >> $1[i];\n\n",
      "\treturn 0;",
      "}"
    ],
    "description": "nと要素数nの配列aを扱うテンプレート",
  },
  "n_m_template": {
    "prefix": "nmtmplt",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "#define rep(i, n) for (int i = 0; i < (n); i++)",
      "#define rep2(i,k,n) for(int i = k;i < (n);i++)",
      "typedef long long ll;",
      "#define repl(i,n) for(ll i = 0;i < (n);i++)",
      "typedef pair <int,int> P;",
      "#define ALL(a) (a).begin(),(a).end()",
      "typedef vector<vector<int>> Graph;",
      "const ll MOD = 1e9 + 7;",
      "const int INF = 1e9;",
      "const ll lINF = 1e18;",
      "const int dx[4] = {1, 0, -1, 0};",
      "const int dy[4] = {0, 1, 0, -1};\n",
      "int main(void){",
      "\tint n,$1,ans = 0;",
      "\tcin >> n >> $1;",
      "\tvector<int> $2(n);",
      "\trep(i, n) cin >> $2[i];\n\n",
      "\treturn 0;",
      "}"
    ],
    "description": "競プロのnとmの2値を扱うテンプレート"
  },
  "vector<int>略": {
    "prefix": "vi",
    "body": "vector<int> ",
    "description": "vector<int>の省略"
  },
  "ans 出力": {
    "prefix": "cans",
    "body": "cout << ans << endl;",
    "description": "ansの出力"
  },
  "Yes 出力": {
    "prefix": "cYe",
    "body": "cout << \"Yes\" << endl;\n",
    "description": "Yesの出力"
  },
  "No 出力": {
    "prefix": "cNo",
    "body": "cout << \"No\" << endl;\n",
    "description": "Noの出力"
  },
  "組み合わせ": {
    "prefix": "comb",
    "body": [
      "template <class T>",
      "T nCr_naive(T n, int r) {",
      "\tT ret(1);",
      "\tfor (int i = 0; i < r; i++) {",
      "\t\tret *= n;",
      "\t\tret /= T(i + 1);",
      "\t\tn -= T(1);",
      "}",
      "\treturn ret;",
      "}",
    ],
    "description": "組み合わせの計算"
  },
  "基数変換": {
    "prefix": "convertb",
    "body": [
      "/*基数変換のためのライブラリ",
      "10進数xをy進数表記にして返す",
      "負の数は扱わない*/",
      "//string 型で返すためconvert_base.c_str()で変換する型の関数に渡す",
      "template <typename T>",
      "string convert_base(T x,T y){",
      "\tstring s;\n",
      "\twhile (x){",
      "\t\ts = to_string(x % y) + s;",
      "\t\tx /= y;",
      "\t}",
      "\treturn s;",
      "}",
      "//int型のみ扱いint型で返す",
      "int convert_base_int(int x,int y){",
      "\tstring s;\n",
      "\twhile (x){",
      "\t\ts = to_string(x % y) + s;",
      "\t\tx /= y;",
      "\t}",
      "\treturn atoi(s.c_str());",
      "}",
    ],
  },
  "editdistance": {
    "prefix": "editdist",
    "body": [
      "int editdistance(string s1,string s2){",
      "\tint a = s1.size(),b = s2.size(),cost;",
      "\tvector<vector<int>> dp(a+1,vector<int>(b+1,0));",
      "\trep(i,a+1) dp[i][0] = i;",
      "\trep(i,b+1) dp[0][i] = i;\n",
      "\trep(i,a){",
      "\t\trep(j,b){",
      "\t\t\tif(s1[i] == s2[j]) cost = 0;",
      "\t\t\telse cost = 1;",
      "\t\t\tdp[i+1][j+1] = min({dp[i+1][j]+1,dp[i][j+1]+1,dp[i][j]+cost});",
      "\t\t}",
      "\t}",
      "\treturn dp[a][b];",
      "}",
    ],
    "description": "エディットディスタンス"
  },
  "Grid0-1bsf": {
    "prefix": "g01bsf",
    "body": [
      "/*0-1幅優先探索",
      "(スタート,ゴール,迷路)",
      "first が行 secondが列",
      "4方向のみ",
      "'.'または'g'がコストのない通路",
      "'#'がコストのある通路*/\n",
      "int bfs01(P s, P g, vector<string> &c){",
      "\tint H = c.size();",
      "\tint W = c[0].size();",
      "\tvector<vector<int>> d(H, vector<int>(W, -1)); //探索で通ったか、コストを記録",
      "\tdeque<P> que;",
      "\tque.push_front(s);",
      "\td[s.first][s.second] = 0;\n",
      "\twhile (que.size()){\n",
      "\t\tP p = que.front();",
      "\t\tque.pop_front();\n",
      "\t\trep(i, 4){",
      "\t\t\tint x = p.first + dx[i], y = p.second + dy[i];\n",
      "\t\t\tif (x < 0 || x >= H || y < 0 || y >= W)",
      "\t\t\t\tcontinue;",
      "\t\t\tif (d[x][y] != -1)",
      "\t\t\t\tcontinue;",
      "\t\t\tif (c[x][y] == '.' || c[x][y] == 'g'){",
      "\t\t\t\td[x][y] = d[p.first][p.second];",
      "\t\t\t\tque.push_front(make_pair(x,y));",
      "\t\t\t}",
      "\t\t\telse if(c[x][y] == '#'){",
      "\t\t\t\td[x][y] = d[p.first][p.second]+1;",
      "\t\t\t\tque.push_back(make_pair(x,y));",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\treturn d[g.first][g.second];",
      "}",
    ],
    "description": "Gridグラフでの01bsf",
  },
  "Gridbsf": {
    "prefix": "gbsf",
    "body": [
      "/*(スタート,ゴール,迷路)",
      "first が行 secondが列",
      "'#'の時通れない。それ以外の時に通れる。",
      "4方向のみ*/",
      "int bfs(P s, P g, vector<string> &c)",
      "{",
      "\tint H = c.size();",
      "\tint W = c[0].size();",
      "\tvector<vector<int>> d(H, vector<int>(W, -1)); //探索で通ったか、コストを記録",
      "\tqueue<P> que;",
      "\tque.push(s);",
      "\td[s.first][s.second] = 0;\n",
      "\twhile (que.size())",
      "\t{",
      "\t\tP p = que.front();",
      "\t\tque.pop();\n",
      "\t\trep(i, 4)",
      "\t\t{",
      "\t\t\tint x = p.first + dx[i], y = p.second + dy[i];\n",
      "\t\t\tif (x < 0 || x >= H || y < 0 || y >= W)",
      "\t\t\t\tcontinue;",
      "\t\t\tif (c[x][y] == '#')",
      "\t\t\t\tcontinue;",
      "\t\t\tif (d[x][y] != -1)",
      "\t\t\t\tcontinue;",
      "\t\t\tif (x == g.first && y == g.second)",
      "\t\t\t{",
      "\t\t\t\td[x][y] = d[p.first][p.second] + 1;",
      "\t\t\t\tbreak;",
      "\t\t\t}",
      "\t\t\tque.push(P(x, y));",
      "\t\t\td[x][y] = d[p.first][p.second] + 1;",
      "\t\t}",
      "\t}",
      "\treturn d[g.first][g.second];",
      "}",
    ],
    "description": "Gridグラフでの幅優先探索",
  },
  "isPrime": {
    "prefix": "isP",
    "body": [
      "/*nが素数であるかbool型で判定*/",
      "bool isPrime(int n){",
      "\tif(n == 2)",
      "\t\treturn true;\n",
      "\tfor(int i = 2;i*i <= n;i++){",
      "\t\tif(n%i == 0)",
      "\t\t\treturn false;",
      "\t}",
      "\treturn true;",
      "}",
    ],
    "description": "素数判定",
  },
  "最長共通部分列": {
    "prefix": "lcsfunc",
    "body": [
      "int lcs(string A,string B){",
      "\tint a = A.size(),b = B.size();",
      "\tvector<vector<int>> dp(a+1,vector<int>(b+1,0));",
      "\trep(i,a){",
      "\t\trep(j,b){",
      "\t\t\tif(A[i] == B[j]){",
      "\t\t\t\tdp[i+1][j+1] =dp[i][j]+1;",
      "\t\t\t}",
      "\t\t\telse{",
      "\t\t\t\tdp[i+1][j+1] = max(dp[i+1][j],dp[i][j+1]);",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\treturn dp[a][b];",
      "}",
    ],
    "description": "最長共通部分列",
  },
  "累積和の計算(前から足す)": {
    "prefix": "cumsump",
    "body": [
      "vector<int> a(n);",
      "vector<int> cm(n+1,0);",
      "//cm[i] はi以降の累積和",
      "rep(i,n){",
      "\tcm[i+1] = cm[i] + a[i];",
      "}",
    ],
    "description": "累積和の計算式",
  },
  "累積和の計算(後ろから)": {
    "prefix": "cumsumb",
    "body": [
      "vector<int> a(n);",
      "vector<int> cm(n,0);",
      "//cm[i] はi以降の累積和",
      "for(int i = n-2;i >= 0;i--){",
      "\tcm[i] = c[i+1] + a[i];",
      "}",
      "//cm[i]*a[i]でよく使う",
    ],
    "description": "累積和の計算式",
  },
  "bit探索":{
    "prefix": "bptmp",
    "body": [
      "rep(bit,(1<<$1)){",
        "\tint cnt = 0;\n",
        "\trep(i,$1){",
            "\t\tif(bit & (1<<i)){",
                "\t\t\t$2",
    "\t\t}",
        "\t}\n",
        "\t$3",
    "}\n",
    ],
    "description": "bit探索"
  },
}